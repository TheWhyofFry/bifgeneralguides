[
{
	"uri": "https://thewhyoffry.github.io/bifgeneralguides/bash/bashphylo/",
	"title": "Prepping Phylogenetic Data With BASH",
	"tags": [],
	"description": "",
	"content": " Introduction General usage of shell environments are restricted to executing simple commands to complete tasks. So\nSome of the previous demonstrations have shown additional functionality provided by default in the shell environment. For instance, you were shown that it was not necessary to copy-paste/retype full pathnames. You can use a shell variable to reference said pathname.\nMYDATAFOLDER=/mnt/lustre/users/username/data/myinputdata #Full path samtools stats /mnt/lustre/users/username/data/myinputdata/something.bam #Variable samtools stats ${MYDATAFOLDER}/something.bam  This is a very trivial example, but still very useful to keep things tidy. It\u0026rsquo;s easy to get lost. Besides aesthetics, the use of a variable is exceptionally useful. We can use them to store output from another command. Let\u0026rsquo;s say you want to keep a collection of all the fasta files in a current directory.\nls *.fasta # our command, just to check 1.fasta 2.fasta 3.fasta # etc MYFASTAFILES=$(ls *.fasta) echo ${MYFASTAFILES}  Let\u0026rsquo;s break this down a bit. First, how do we define a variable and do we access the value of a variable? We define a variable as VARIABLENAME=SOMEVALUE. Where VARIABLENAME can be any abitrary name that (I think) has to start with an non-numeric normal character. The SOMEVALUE part can be a number, VARIABLENAME=5, a string (a string is a sequence of characters), VARIABLENAME=\u0026quot;Goody bash\u0026quot;, or the output of a command. For the last part, we can capture command output by wrapping the command in $() (Note, some guides will tell you that you can also use backicks, `, but this is deprecated in favour of $()). So the output you see when you type ls *.fasta is now redirected to the variable when you encapsulate as$(ls *.fasta).\nManipulating variables Variables are by definition not static entities and can easily be changed to something else. Indeed, by using the expression ${MYDATAFOLDER}/something.bam, you are creating a new (unnnamed) variable that combines the value of MYDATAFOLDER and /something.bam. Values of variables can be manipulated in interesting ways. A lot of time when dealing with many data files, you\u0026rsquo;ll sit with a situation where manual grouping of data according to sample/group/etc becomes really difficult.\nTake a look at the following filenames:\n036-2012P_S1.out 036-2024P_S2.out 036-2036P_S3.out 039-2002-0_S61.out 079-2003-5_S62.out 079-2004P_S5.out 079-2012P_S6.out 079-2024P_S7.out 079-2036P_S8.out 079-2036_S3.out 093-2001_S2.out 093-2002P_S10.out 093-2002_S4.out 093-2004P_S11.out 093-2012-0_S63.out 093-2012P_S12.out 093-2024-0_S64.out 093-2024P_S13.out 093-2036P_S14.out 102-2002-0_S65.out 102-2004P_S15.out 102-2012-0_S66.out 102-2012P_S16.out 102-2012_S5.out 102-2024-0_S67.out 102-2024P_S17.out 102-2036-0_S68.out 102-2048P_S19.out  The format of each filename is:\n 036 - 2012P _ S1 .out (group)-(sample)_(sampleid).(ext)  I would like to organize these files by moving all the files belogning to the same group into a new folder. I would like this folder to be named according to the group name. Furthermore, the filenames should only contain the sample name (without sample id) and a different extension, \u0026ldquo;.txt\u0026rdquo;.\n036-2012P_S1.out --\u0026gt; 036/2012P.txt  How remove everything after the group number? We know that the group number is always followed by a dash (-). There are actually multiple ways of doing this. The cut command allows you to extract columns from text files, given a delimeter (separator). So we could technically use the dash as the delimiter and extact the first column:\necho \u0026quot;036-2012P_S1.out\u0026quot; | cut -f 1 -d\\- 036 #Store it GROUPNAME=$(echo \u0026quot;036-2012P_S1.out\u0026quot; | cut -f 1 -d\\-) echo ${GROUPNAME} 036  But it\u0026rsquo;s quite cumbersome to do this, not to mention inefficient. For every file, we need to use the \u0026ldquo;cut\u0026rdquo; just to get the prefix of a file (which is the group in this case). Alternative, we could use built in BASH string substitution commands. To remove a suffix, an implicitly be left with a prefix:\n${VARIABLE%%[pattern]} FILENAME=\u0026quot;036-2012P_S1.out\u0026quot; GROUPNAME=${FILENAME%%-*} echo ${GROUPNAME} 036  The % operator tell BASH to remove everything after and including that which matches [pattern]. The pattern in this case is the first dash and everything after that. If you were to play around with the command a bit, you\u0026rsquo;d see the following:\necho ${FILENAME%1*} # Remove everything after the last occurrence of \u0026quot;1\u0026quot; 036-2012P_S echo ${FILENAME%%1*} # Remove everything after the first occurrence of \u0026quot;1\u0026quot;  The command may seem a little confusing, but fret not. The search for a pattern actually starts from the end of the line. A single % indicates that everything gets deleted from the end of the string up to the first match. A double %% indicates that everything gets deleted up to the final match starting from the end of the line.\nSo now we know how to generate the group name. Next, we need to extract the sample name. We need to remove the group prefix and everything from the sample id onward. Then add the .txt extension.\nSUFFIX=${FILENAME#*-} echo ${SUFFIX} 2012P_S1.out SAMPLE=${SUFFIX%%_*} echo ${SAMPLE} 2012P  So the # operator removes everything before and including a match. The example above removed everything up to and including the first \u0026ldquo;-\u0026rdquo;. However, we still need to remove the trailing bits, so the following command assigns the SAMPLE variable as the SUFFIX variable minus the pesky suffix, i.e. _S1.out.\nFinally, we can construct the desired filename:\nFINALNAME=${GROUPNAME}/${SAMPLE}.txt echo ${FINALNAME}  Great, but how do we put this all together? We still have many files to go through and it would be a bit slow to do this procedure for every single filename manually. We can use loops\nFor loops For loops are loops that go through items in some sort of list. With each iteration, this item grabbed from the list can be used in whatever way you see fit. We\u0026rsquo;ll loop through the files in our directory.\nfor file in *.out do FILENAME=$(basename ${file}) # removes the path - not really needed here GROUPNAME=${FILENAME%%-*} SUFFIX=${FILENAME#*-} SAMPLE=${SUFFIX%%_*} FINALNAME=${GROUPNAME}/${SAMPLE}.txt echo \u0026quot;mkdir -p out/${GROUPNAME}; cp ${file} out/${FINALNAME}\u0026quot; done  Let\u0026rsquo;s look at the anatomy of a for loop:\n The first line of the for loop here sets up what to loop through and where to store the value after each iteration. So for each file in *.out means for each filename matching the pattern *.out, i.e. all files ending with *.out in the current directory. An equivalent command would be for file in $(ls *.out). Each filename will then be passed to file. The do and done words mark the beginning and end of the content part of the loop. And everything between the two words will be executed as long as there are more *.out files to go through.\n Disregarding the content between the do and done parts, if this loop were to run, and the files one.out, two.out and three.out existed in the current folder, the value of file would be one.out first, and when the loop restarts, two.out and finally three.out after which the loop will end. And code (if any) below the for loop will be executed. The main content of the loop:  FILENAME=$(basename ${file}) - In this example, this step is not really necessary, but we would rather like the basename of a file. The basename is the filename without a prefixed path, e.g. basename /mnt/your/file.txt becomes file.txt. By using round brackets and a $, the output of the basename command is then stored in the FILENAME variable. GROUPNAME=${FILENAME%%-*} - As mentioned before, we would like the first part of the filename to be used as the assigned group. The %% means remove everything, including the pattern following %%, i.e. the first occurrence of - up to the end of the string. So \u0026ldquo;0123-12312_\u0026hellip;.\u0026rdquo; becomes \u0026ldquo;0123\u0026rdquo;, \u0026ldquo;ABCDEF-12345-6789\u0026rdquo; becomes \u0026ldquo;ABCDEF\u0026rdquo; and so on. This search is performed left to right, so it will greedily (as denoted by %%) remove the pattern matched up until the last match. SUFFIX=${FILENAME#*-} - Remove the group name prefix from the filename. This search is performed from left to right, and will only remove up to the first occurrence of the pattern. In this case, \u0026ldquo;ABCDEF-12345-6789\u0026rdquo; will become \u0026ldquo;12345-6789\u0026rdquo;. How would this change if the pattern matching was done greedily, i.e. \u0026ldquo;${FILENAME##*-}\u0026ldquo;? SAMPLE=${SUFFIX%%_*} - As for group name, remove everything after the sample name part. FINALNAME=${GROUPNAME}/${SAMPLE}.txt - Concatenate the group name and the sample name. This is what our final name should look like. It will be put under the group name path with the sample name as the final filename. echo \u0026quot;mkdir -p out/${GROUPNAME}; cp ${file} out/${FINALNAME}\u0026quot; - This command won\u0026rsquo;t actuall make the path and copy the file name to its new name. It will only print the command to screen. Personally, I do this before actually executing the command to make sure I didn\u0026rsquo;t mess up. The final command would first make a directory with the \u0026ldquo;mkdir\u0026rdquo; command. The semicolor \u0026ldquo;;\u0026rdquo; indicates that a new command follows it, which is \u0026ldquo;cp\u0026rdquo; in this case.  This loop continues until there are no more files to analyze.  Remember to include the parameters of echo in quotes. If you remove the quites, the following will happen (using the filename \u0026ldquo;036-2012P_S1.out\u0026rdquo; as an example):\n echo mkdir -p out/036 mkdir -p out/036  cp 036-2012P_S1.out out/2012P.txt No such file: out (or something similar)   This is because the \u0026ldquo;;\u0026rdquo; will tell bash that the current command (echo) ends here and that a new command is executed. Putting everything in quotes ensures that the entire line is only printed to screen.\n It is important to make sure that the command you executed works well. Indeed, if we run this loop, we\u0026rsquo;ll notice the following:\nmkdir -p out/568; cp 568-2001-0_S89.out out/568/2001-0.txt ^^^  So this has to do with the SAMPLENAME variable. So it seems we need to look for an _ and a -. Change the SAMPLE=${SUFFIX%%_*} line to SAMPLE=${SUFFIX%%[_-]*. The block brackets say that the pattern can match either - or _ in the beginning.\nfor file in *.out do FILENAME=$(basename ${file}) # removes the path - not really needed here GROUPNAME=${FILENAME%%-*} SUFFIX=${FILENAME#*-} SAMPLE=${SUFFIX%%[_-]*} FINALNAME=${GROUPNAME}/${SAMPLE}.txt echo \u0026quot;mkdir -p out/${GROUPNAME}; cp ${file} out/${FINALNAME}\u0026quot; done  And this produces a much better output\n mkdir -p out/036; cp 036-2012P_S1.out out/036/2012P.txt mkdir -p out/036; cp 036-2024P_S2.out out/036/2024P.txt mkdir -p out/036; cp 036-2036P_S3.out out/036/2036P.txt mkdir -p out/039; cp 039-2002-0_S61.out out/039/2002.txt mkdir -p out/079; cp 079-2003-5_S62.out out/079/2003.txt mkdir -p out/079; cp 079-2004P_S5.out out/079/2004P.txt mkdir -p out/079; cp 079-2012P_S6.out out/079/2012P.txt mkdir -p out/079; cp 079-2024P_S7.out out/079/2024P.txt mkdir -p out/079; cp 079-2036P_S8.out out/079/2036P.txt mkdir -p out/079; cp 079-2036_S3.out out/079/2036.txt mkdir -p out/093; cp 093-2001_S2.out out/093/2001.txt mkdir -p out/093; cp 093-2002P_S10.out out/093/2002P.txt mkdir -p out/093; cp 093-2002_S4.out out/093/2002.txt mkdir -p out/093; cp 093-2004P_S11.out out/093/2004P.txt mkdir -p out/093; cp 093-2012-0_S63.out out/093/2012.txt mkdir -p out/093; cp 093-2012P_S12.out out/093/2012P.txt mkdir -p out/093; cp 093-2024-0_S64.out out/093/2024.txt mkdir -p out/093; cp 093-2024P_S13.out out/093/2024P.txt  How to run this loop You can enter the loop in a terminal as-is. But it is generally better to put everything into a file, say renamescript.bash and then execute it with bash renamescript.bash. As an aside, you can add the following to the very beginning of the file:\n#!/bin/bash  And then, in the folder containing the script, type:\nchmod a+x renamescript.bash  However, if you\u0026rsquo;re using git bash, I\u0026rsquo;m unsure what the behaviour would be, so perhaps better to use the bash renamescript.bash command. If this doesn\u0026rsquo;t work, try source renamescript.bash.\nBefore we move on An alternative \u0026ldquo;renaming\u0026rdquo; scheme Of course, instead of copying the file as a new filename, we could just make symbolic links. Symbolic links act as a placeholder and references to the original filename. To do it this way, we replace the \u0026ldquo;echo\u0026rdquo; line:\necho \u0026quot;mkdir -p out/${GROUPNAME}; cp ${file} out/${FILENAME}\u0026quot; #Replace this with: echo \u0026quot;mkdir -p out/${GROUPNAME}; ln -s ${file} out/${FILENAME}\u0026quot; #If the original files won't be moved, we can use absolute paths, since these will give relative paths: echo \u0026quot;mkdir -p out/${GROUPNAME}; ln -s $(realpath ${file}) out/${FILENAME}\u0026quot;  The realpath command gives the absolute path of the filename, i.e. something in \u0026ldquo;/mnt/user/data/something\u0026rdquo; is just referred to as \u0026ldquo;something\u0026rdquo; by default, while using realpath samplename will give you \u0026ldquo;/mnt/user/data/something\u0026rdquo;.\nSomething doesn\u0026rsquo;t work It happens :-) In this example, I\u0026rsquo;m fairly certain that the main mistakes you\u0026rsquo;d make would be:\n Forgetting the difference between $() and ${}. The $() means \u0026ldquo;please use the output from program X as a value, while the ${} means \u0026ldquo;please use the value of the variable between {}. Forgetting your quotes after \u0026ldquo;echo\u0026rdquo;. See the previous paragraphs. Seeing an annoying \u0026gt; that doesn\u0026rsquo;t seem to go away. Check if your for loop has a do and done part. The \u0026gt; means that BASH is either expecting more input (e.g. type \u0026quot; and enter on a line) or that it is still within a \u0026ldquo;block\u0026rdquo; such as an unterminated for loop.  An exercise Hopefully you understand, at least in principle, what was discussed in the previous section. If you are unsure about something, read it again. If you still don\u0026rsquo;t understand, then my explanation has failed you and you are welcome to do a quick web search on the topic - and please spread the word.\nFor newcomers and even intermediate users, the following exercise (namesake of the title) may seem a bit challenging at first. This is something I had to personally do. It is quite a fun exercise when you get it right. Bioinformatics, like most things in science, is about abstracting a problem and then pooling together the necessary tools to reach a goal. Bear with me, it has something to do with phylogenetics, \u0026ndash;phylogenomics more specifically\u0026ndash; (nope, I don\u0026rsquo;t want to lose you already).\nI will describe the general nature of the problem, so you can see where we\u0026rsquo;re heading with it and then give you a task to complete. For each step, the answers will be hidden to you, but you are allowed to sneak a peak. Try to do this only if you are really stuck.\nGenerating a concatenated model file Phylogenetics is used to find the relationship between sequences. A phylogenetic tree might give you information on the evolutionary history and/or grouping of sequences. An example would be using hox genes to do large evolutionary classifications. A phylogeny is based on the topology of a tree and the branches. I won\u0026rsquo;t go into too much detail (and omitting quite a bit in the process), but the branch lengths indicate how \u0026ldquo;far\u0026rdquo; a sequence is to the common ancestor of its neighbour. The sequences together with a model can be used to find this optimal branch length and topology. To do a general comparison between organisms, select sequences are used and a combined phylogeny is created. However, different sequences evolve at different rates and according to different substitution models. I have a set of ~1400 sequences for which I have determined the optimal substitution model. What I need now, is a file that contains the sequence name and the appropriate model. An example of the output:\n100.fas,LG4X 101.fas,JTT+G 200.fas,JTT  So the output needs to be of a \u0026ldquo;CSV\u0026rdquo; (comma separated value) nature. In loose terms, a sort of spread sheet. The first column needs to have the appropriate FASTA file, while the second column will contain the best model for making a phylogenetic inference.\nIf you look at the model folder in the example data, you will see there are ~1400 files. Each of them have a \u0026ldquo;.mod\u0026rdquo; extension. Within this file, there is a specific line that determines the best model for the sequences at hand. The line we would like to use, is:\nBest model according to AIC: JTT  To get this line, we can use the grep command. The grep command will print lines in a file matching a pattern you specify. So if you are in the model folder, you can type:\ngrep \u0026quot;Best model according to AIC\u0026quot; 100.mod Best model according to AIC: LG+I+G+F  And it will give you the appropriate line in the file.\nIf you manually look at the files, you may notice that there are similar lines, replacing the \u0026ldquo;AIC\u0026rdquo; part with \u0026ldquo;BIC\u0026rdquo;. We can ignore those. If you look at this line, we can see that the part we need to extract is after the string (pattern) \u0026ldquo;AIC: \u0026ldquo;. To get this model, we need to first extract the line from the file with grep and then remove the \u0026ldquo;The best model \u0026hellip;. AIC:\u0026rdquo; part. Two tasks:\n Extract the line containing \u0026ldquo;The best model \u0026hellip;. \u0026rdquo; from the 100.mod file and assign it to a variable named MODELLINE Remove everyting in the line preceding the model part and assign this to MODEL    Show me   #Make sure you are in the \u0026quot;model\u0026quot; directory MODELLINE=$(grep \u0026quot;Best model according to AIC\u0026quot; 100.mod) MODEL=${MODELLINE#*AIC: } # Don't need the entire string, we know there is only one instance of \u0026quot;AIC: \u0026quot; echo ${MODEL} LG+I+G+F    Great! Now, let\u0026rsquo;s manually assign the value \u0026ldquo;100.mod\u0026rdquo; to the variable MODELFILENAME.\n  Show me   MODELFILENAME=\u0026quot;100.mod\u0026quot; # or: MODELFILENAME=100.mod    We need to concatenate (join) these variables using a comma as a separator. You can look at the previous sections to see how to join values of variables together. Assing the variable OUTPUT to this concatenated value or use echo to print it out.\n  Show me   # Assign to variable OUTPUT=${MODELFILENAME},${MODEL} echo ${OUTPUT} #or echo \u0026quot;${MODELFILENAME},${MODEL}\u0026quot; 100.mod,LG+I+G+F    However, there\u0026rsquo;s a problem here. The FASTA file corresponding to the model file ends with \u0026ldquo;.fas\u0026rdquo;, so you need to remove the suffix of MODELFILENAME and add .fas to it.\n  Show me   FASTAFILENAME=${MODELFILENAME%%.out}.fas echo \u0026quot;${FASTAFILENAME},${MODEL}\u0026quot; 100.fas,LG+I+G+F    Now you have your steps to generate the desired output. Next, the procedure should be wrapped in a for loop. Make sure you are in the models folder for this. You need to loop over all the .mod files, using MODELFILENAME as the variable to store the filename with each iteration of the loop. You need to save the extracted MODELLINE and then extract the MODEL from this. The FASTAFILENAME should be created from MODELFILENAME. The CSV-styled output should be produced with \u0026ldquo;echo\u0026rdquo;. Edit a text file called \u0026ldquo;extractmodels.bash\u0026rdquo; (or whatever you like) and put your for loop inside.\n  Show me   for MODELFILENAME in *.mod do MODELLINE=$(grep \u0026quot;Best model according to AIC\u0026quot; ${MODELFILENAME}) MODEL=${MODELLINE#*AIC: } FASTAFILENAME=${MODELFILENAME%%.mod}.fas echo \u0026quot;${FASTAFILENAME},${MODEL}\u0026quot; done    When you run the script inside the models folder (if the script is in another folder, change your command accordingly). The output should be printed onto the screen. In order to write this output to a file, you might do:\nbash extractmodels.bash \u0026gt; allmodels.txt head allmodels.txt 1000.fas,JTT+I+G+F 1004.fas,LG+I+G+F 10064.fas,WAG+I+G 10075.fas,Dayhoff+I+G 1008.fas,LG+I+G+F 10095.fas,JTT+I+G 100.fas,LG+I+G+F 1013.fas,LG+I+G+F 10153.fas,LG+I+G+F 1015.fas,WAG+I+G  The output of the bash command is redirected by \u0026gt; to a file. Your excercise is now done. There are many more awesome things you can do. Hopefully you would now have more confidence to try :-)\n-WS\n"
},
{
	"uri": "https://thewhyoffry.github.io/bifgeneralguides/bash/_intro/",
	"title": "BASH",
	"tags": [],
	"description": "",
	"content": " Bourne Again SHell Simple guides for an awesome shell\n"
},
{
	"uri": "https://thewhyoffry.github.io/bifgeneralguides/introduction/welcome/",
	"title": "Welcome",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://thewhyoffry.github.io/bifgeneralguides/introduction/",
	"title": "_index",
	"tags": [],
	"description": "",
	"content": "A notice disclaimer\n "
},
{
	"uri": "https://thewhyoffry.github.io/bifgeneralguides/bash/",
	"title": "Bashes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://thewhyoffry.github.io/bifgeneralguides/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://thewhyoffry.github.io/bifgeneralguides/",
	"title": "General BIF guides",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://thewhyoffry.github.io/bifgeneralguides/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]